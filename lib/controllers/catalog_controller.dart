import 'dart:developer';

import 'package:api_handler/api_handler.dart';
import 'package:bonus_api/bonus_api.dart';
import 'package:bonus_repository/bonus_repository.dart';
import 'package:get/get.dart';
import 'package:training_and_testing/controllers/controllers.dart';

class CatalogController extends GetxController {
  CatalogController({
    required IBonusRepository bonusRepository,
    required UserController userController,
  })  : _bonusRepository = bonusRepository,
        _userController = userController;

  final IBonusRepository _bonusRepository;
  final UserController _userController;

  // definitions.

  final _selectedCategory = Rxn<CatalogCategoryModel>();
  final _isProductsLoading = Rx<bool>(false);

  // getters.

  Rxn<CatalogCategoryModel> get selectedCategory => _selectedCategory;
  Rx<Future<UserBalanceModel>> get userBalance => _userController.userBalance;
  bool get isCategoriesLoading => _isProductsLoading.value;

  /// Future to get list of categories.
  final categoriesFuture = Rxn<Future<List<CatalogCategoryModel>>>();

  /// Future to get list of products.
  final productsFuture = Rxn<Future<List<CatalogProductModel>>>();

  // setters.

  void updateSelectedCategory([CatalogCategoryModel? value]) {
    if (value == _selectedCategory.value) {
      _selectedCategory.value = null;
    } else {
      _selectedCategory.value = value;
    }
  }

  // methods.

  @override
  void onInit() {
    super.onInit();

    reload();
  }

  Future<void> reload() async {
    await loadCategories();
    await loadProducts(_selectedCategory.value);
  }

  Future<void> loadCategories() async {
    log(
      'Fetching categories...',
      name: 'CatalogController::_fetchCategories',
    );

    categoriesFuture.value = _bonusRepository.getCatalogCategories();
  }

  Future<void> loadProducts([CatalogCategoryModel? category]) async {
    log(
      'Getting products...',
      name: 'CatalogController::_getProducts',
    );

    _isProductsLoading.value = true;

    try {
      productsFuture.value = _bonusRepository.getCatalogProducts(
        category: category?.slug,
      );
      await productsFuture.value;
    } finally {
      updateSelectedCategory(category);
      _isProductsLoading.value = false;
    }
  }
}

/// Groups [list] by provided [groupBy] function. Returns a Map with keys
/// generated by [groupBy] function and values as a list of items from [list].
///
/// Example:
/// ```dart
/// final nums = [1, 2, 1];
///
/// final groupedNums = groupListBy(nums, (num) => num); // {1: [1, 1], 2: [2]}
/// ```
Map<T, List<E>> groupListBy<T, E>(
  List<E> list,
  T Function(E) groupBy,
) {
  final groupedProducts = <T, List<E>>{};

  for (final item in list) {
    final key = groupBy(item);

    if (!groupedProducts.containsKey(key)) {
      groupedProducts[key] = [];
    }

    groupedProducts[key]!.add(item);
  }

  return groupedProducts;
}

/// Wrap the requests, updates the loading values and errors.
Future<void> performRequest<T>({
  required Future<T> Function() callback,
  Rx<bool>? loadingIndicator,
  Rxn<ApiNetworkException>? error,
}) async {
  error?.value = null;

  try {
    loadingIndicator?.value = true;

    await callback();
  } on ApiNetworkException catch (e) {
    error?.value = e;
  } finally {
    loadingIndicator?.value = false;
  }
}
