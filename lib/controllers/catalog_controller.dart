import 'dart:developer';

import 'package:api_handler/api_handler.dart';
import 'package:bonus_api/bonus_api.dart';
import 'package:bonus_repository/bonus_repository.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class CatalogController extends GetxController {
  CatalogController({
    required CatalogBonusRepository catalogRepository,
  }) : _catalogRepository = catalogRepository;

  final CatalogBonusRepository _catalogRepository;

  // definitions.

  final _balance = 0.obs;
  final _categories = RxList<CatalogCategoryModel>([]);
  final _products = RxList<CatalogProductModel>([]);
  final _selectedCategory = Rxn<CatalogCategoryModel>();
  final _isBalanceLoading = false.obs;
  final _isCategoriesLoading = true.obs;
  final _isProductsLoading = false.obs;
  final _error = Rxn<ApiNetworkException>();

  // getters.

  int get balance => _balance.value;
  List<CatalogCategoryModel> get categories => _categories;
  List<CatalogProductModel> get products => _products;
  CatalogCategoryModel? get selectedCategory => _selectedCategory.value;
  bool get isBalanceLoading => _isBalanceLoading.value;
  bool get isCategoriesLoading => _isCategoriesLoading.value;
  bool get isProductsLoading => _isProductsLoading.value;
  Rxn<ApiNetworkException> get error => _error;
  bool get isControllerLoading => [
        _isBalanceLoading,
        _isCategoriesLoading,
        _isProductsLoading,
      ].any((element) => element.value);

  final categoriesFuture = Rxn<Future<List<CatalogCategoryModel>>>();
  final productsFuture = Rxn<Future<List<CatalogProductModel>>>();

  // setters.

  set selectedCategory(CatalogCategoryModel? value) {
    if (value?.id == _selectedCategory.value?.id) {
      _selectedCategory.value = null;
    } else {
      _selectedCategory.value = value;
    }
  }

  // methods.

  @override
  void onInit() {
    super.onInit();

    fetchCategories();
    // _getProducts();

    /// Load products every time the selected category changes.
    // ever(
    //   _selectedCategory,
    //   _getProducts,
    // );
    _selectedCategory.listenAndPump((category) {
      getProducts(category);

      update();
    });
  }

  void handleError(BuildContext context) {
    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(
        SnackBar(content: Text(_error.value?.message ?? 'Error')),
      );
  }

  Future<void> fetchCategories() async {
    log(
      'Fetching categories...',
      name: 'CatalogController::_fetchCategories',
    );
    // await performRequest(
    //   error: _error,
    //   loadingIndicator: _isCategoriesLoading,
    //   callback: () async {
    //     // load categories.
    //     final categories = await _catalogRepository.getCatalogCategories();

    //     // update categories list.
    //     _categories
    //       ..clear()
    //       ..addAll(categories);
    //   },
    // );

    categoriesFuture.trigger(_catalogRepository.getCatalogCategories());
    _selectedCategory.trigger(null);
  }

  Future<void> getProducts([CatalogCategoryModel? category]) async {
    log(
      'Getting products...',
      name: 'CatalogController::_getProducts',
    );

    // await performRequest(
    //   error: _error,
    //   loadingIndicator: _isProductsLoading,
    //   callback: () async {
    //     // load products.
    //     final products = await _catalogRepository.getCatalogProducts(
    //       category: category?.slug,
    //     );

    //     // update products list.
    //     _products.value = products;
    //   },
    // );

    // print('products: ${_products.length}');

    productsFuture.trigger(
      _catalogRepository.getCatalogProducts(
        category: category?.slug,
      ),
    );
  }
}

/// Groups [list] by provided [groupBy] function. Returns a Map with keys
/// generated by [groupBy] function and values as a list of items from [list].
///
/// Example:
/// ```dart
/// final nums = [1, 2, 1];
///
/// final groupedNums = groupListBy(nums, (num) => num); // {1: [1, 1], 2: [2]}
/// ```
Map<T, List<E>> groupListBy<T, E>(
  List<E> list,
  T Function(E) groupBy,
) {
  final groupedProducts = <T, List<E>>{};

  for (final item in list) {
    final key = groupBy(item);

    if (!groupedProducts.containsKey(key)) {
      groupedProducts[key] = [];
    }

    groupedProducts[key]!.add(item);
  }

  return groupedProducts;
}

/// Wrap the requests, updates the loading values and errors.
Future<void> performRequest<T>({
  required Future<T> Function() callback,
  Rx<bool>? loadingIndicator,
  Rxn<ApiNetworkException>? error,
}) async {
  error?.value = null;

  try {
    loadingIndicator?.value = true;

    await callback();
  } on ApiNetworkException catch (e) {
    error?.value = e;
  } finally {
    loadingIndicator?.value = false;
  }
}
