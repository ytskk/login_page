import 'dart:developer';

import 'package:api_handler/api_handler.dart';
import 'package:bonus_api/bonus_api.dart';
import 'package:bonus_repository/bonus_repository.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class CatalogController extends GetxController {
  CatalogController({
    required CatalogBonusRepository catalogRepository,
  }) : _catalogRepository = catalogRepository;

  final CatalogBonusRepository _catalogRepository;

  // definitions.

  final _balance = 0.obs;
  final _selectedCategory = Rxn<CatalogCategoryModel>();
  final _error = Rxn<ApiNetworkException>();

  // getters.

  int get balance => _balance.value;
  Rxn<CatalogCategoryModel> get selectedCategory => _selectedCategory;
  Rxn<ApiNetworkException> get error => _error;

  /// Future to get list of categories.
  final categoriesFuture = Rxn<Future<List<CatalogCategoryModel>>>();

  /// Future to get list of products.
  final productsFuture = Rxn<Future<List<CatalogProductModel>>>();

  // setters.

  void updateSelectedCategory([CatalogCategoryModel? value]) {
    if (value?.id == _selectedCategory.value?.id) {
      _selectedCategory.value = null;
    } else {
      _selectedCategory.value = value;
    }
  }

  // methods.

  @override
  void onInit() {
    super.onInit();

    fetchCategories();

    /// Listen to changes in the selected category and load products.
    _selectedCategory.listen(getProducts);
  }

  void handleError(BuildContext context) {
    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(
        SnackBar(content: Text(_error.value?.message ?? 'Error')),
      );
  }

  Future<void> fetchCategories() async {
    log(
      'Fetching categories...',
      name: 'CatalogController::_fetchCategories',
    );
    // await performRequest(
    //   error: _error,
    //   loadingIndicator: _isCategoriesLoading,
    //   callback: () async {
    //     // load categories.
    //     final categories = await _catalogRepository.getCatalogCategories();

    //     // update categories list.
    //     _categories
    //       ..clear()
    //       ..addAll(categories);
    //   },
    // );

    categoriesFuture.value =
        _catalogRepository.getCatalogCategories().then((value) {
      // force to update the selected category.
      _selectedCategory.trigger(_selectedCategory.value);
      return value;
    });
  }

  Future<void> getProducts([CatalogCategoryModel? category]) async {
    log(
      'Getting products...',
      name: 'CatalogController::_getProducts',
    );

    productsFuture.value = _catalogRepository.getCatalogProducts(
      category: category?.slug,
    );
  }
}

/// Groups [list] by provided [groupBy] function. Returns a Map with keys
/// generated by [groupBy] function and values as a list of items from [list].
///
/// Example:
/// ```dart
/// final nums = [1, 2, 1];
///
/// final groupedNums = groupListBy(nums, (num) => num); // {1: [1, 1], 2: [2]}
/// ```
Map<T, List<E>> groupListBy<T, E>(
  List<E> list,
  T Function(E) groupBy,
) {
  final groupedProducts = <T, List<E>>{};

  for (final item in list) {
    final key = groupBy(item);

    if (!groupedProducts.containsKey(key)) {
      groupedProducts[key] = [];
    }

    groupedProducts[key]!.add(item);
  }

  return groupedProducts;
}

/// Wrap the requests, updates the loading values and errors.
Future<void> performRequest<T>({
  required Future<T> Function() callback,
  Rx<bool>? loadingIndicator,
  Rxn<ApiNetworkException>? error,
}) async {
  error?.value = null;

  try {
    loadingIndicator?.value = true;

    await callback();
  } on ApiNetworkException catch (e) {
    error?.value = e;
  } finally {
    loadingIndicator?.value = false;
  }
}
